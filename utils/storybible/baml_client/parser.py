###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
from typing import Any, Dict, List, Optional, Union, TypedDict, Type, Literal, cast
from typing_extensions import NotRequired

import baml_py

from . import types, partial_types
from .types import Checked, Check
from .type_builder import TypeBuilder


class BamlCallOptions(TypedDict, total=False):
    tb: NotRequired[TypeBuilder]
    client_registry: NotRequired[baml_py.baml_py.ClientRegistry]


class LlmResponseParser:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager

    
    def EnhanceCharacterProfile(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Character:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "EnhanceCharacterProfile",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Character, parsed)
    
    def ExtractAgentParticipations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.AgentParticipation]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractAgentParticipations",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.AgentParticipation], parsed)
    
    def ExtractAgents(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Agent]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractAgents",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.Agent], parsed)
    
    def ExtractEventInteractions(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.EventInteractions:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractEventInteractions",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.EventInteractions, parsed)
    
    def ExtractEvents(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Event]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractEvents",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.Event], parsed)
    
    def ExtractLocations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Location]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractLocations",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.Location], parsed)
    
    def ExtractObjectInvolvements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ObjectInvolvement]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractObjectInvolvements",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ObjectInvolvement], parsed)
    
    def ExtractObjects(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Object]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractObjects",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.Object], parsed)
    
    def ExtractOrganizations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.Organization]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractOrganizations",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.Organization], parsed)
    
    def ExtractPrimaryEntities(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.PrimaryEntities:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractPrimaryEntities",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.PrimaryEntities, parsed)
    
    def ExtractSceneData(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SceneData:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneData",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.SceneData, parsed)
    
    def ExtractSceneElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SceneElements:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneElements",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.SceneElements, parsed)
    
    def ExtractSceneMetadata(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SceneMetadata:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneMetadata",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.SceneMetadata, parsed)
    
    def GeneratePolishedExecutiveSummary(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "GeneratePolishedExecutiveSummary",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Summary, parsed)
    
    def GenerateStoryTreatment(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Treatment:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "GenerateStoryTreatment",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Treatment, parsed)
    
    def IdentifySceneHeadingPattern(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SceneHeadingPatterns:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "IdentifySceneHeadingPattern",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.SceneHeadingPatterns, parsed)
    
    def MergeSceneElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.StoryElements:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "MergeSceneElements",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.StoryElements, parsed)
    
    def MergeSummariesWithContext(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "MergeSummariesWithContext",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Summary, parsed)
    
    def PreScanCharacters(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.CharacterIndex]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "PreScanCharacters",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.CharacterIndex], parsed)
    
    def ResolveAgentCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ResolvedAgent]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveAgentCluster",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ResolvedAgent], parsed)
    
    def ResolveLocationCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ResolvedLocation]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveLocationCluster",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ResolvedLocation], parsed)
    
    def ResolveObjectCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ResolvedObject]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveObjectCluster",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ResolvedObject], parsed)
    
    def ResolveOrganizationCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ResolvedOrganization]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveOrganizationCluster",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ResolvedOrganization], parsed)
    
    def SummarizeChunkWithContext(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "SummarizeChunkWithContext",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Summary, parsed)
    
    def SynthesizeNarrativeFromElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "SynthesizeNarrativeFromElements",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.Summary, parsed)
    
    def TrackConflictTrajectory(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[types.ConflictArc]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "TrackConflictTrajectory",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[types.ConflictArc], parsed)
    
    def ValidateCypher(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.CypherQuery:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ValidateCypher",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.CypherQuery, parsed)
    
    def ValidateCypherOld(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> types.CypherQuery:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ValidateCypherOld",
        llm_response,
        types,
        types,
        partial_types,
        False,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(types.CypherQuery, parsed)
    


class LlmStreamParser:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager

    
    def EnhanceCharacterProfile(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Character:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "EnhanceCharacterProfile",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Character, parsed)
    
    def ExtractAgentParticipations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.AgentParticipation]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractAgentParticipations",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.AgentParticipation], parsed)
    
    def ExtractAgents(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.Agent]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractAgents",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.Agent], parsed)
    
    def ExtractEventInteractions(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.EventInteractions:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractEventInteractions",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.EventInteractions, parsed)
    
    def ExtractEvents(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.Event]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractEvents",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.Event], parsed)
    
    def ExtractLocations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.Location]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractLocations",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.Location], parsed)
    
    def ExtractObjectInvolvements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ObjectInvolvement]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractObjectInvolvements",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ObjectInvolvement], parsed)
    
    def ExtractObjects(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.Object]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractObjects",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.Object], parsed)
    
    def ExtractOrganizations(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.Organization]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractOrganizations",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.Organization], parsed)
    
    def ExtractPrimaryEntities(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.PrimaryEntities:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractPrimaryEntities",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.PrimaryEntities, parsed)
    
    def ExtractSceneData(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.SceneData:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneData",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.SceneData, parsed)
    
    def ExtractSceneElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.SceneElements:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneElements",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.SceneElements, parsed)
    
    def ExtractSceneMetadata(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.SceneMetadata:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ExtractSceneMetadata",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.SceneMetadata, parsed)
    
    def GeneratePolishedExecutiveSummary(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "GeneratePolishedExecutiveSummary",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Summary, parsed)
    
    def GenerateStoryTreatment(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Treatment:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "GenerateStoryTreatment",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Treatment, parsed)
    
    def IdentifySceneHeadingPattern(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.SceneHeadingPatterns:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "IdentifySceneHeadingPattern",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.SceneHeadingPatterns, parsed)
    
    def MergeSceneElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.StoryElements:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "MergeSceneElements",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.StoryElements, parsed)
    
    def MergeSummariesWithContext(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "MergeSummariesWithContext",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Summary, parsed)
    
    def PreScanCharacters(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.CharacterIndex]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "PreScanCharacters",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.CharacterIndex], parsed)
    
    def ResolveAgentCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ResolvedAgent]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveAgentCluster",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ResolvedAgent], parsed)
    
    def ResolveLocationCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ResolvedLocation]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveLocationCluster",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ResolvedLocation], parsed)
    
    def ResolveObjectCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ResolvedObject]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveObjectCluster",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ResolvedObject], parsed)
    
    def ResolveOrganizationCluster(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ResolvedOrganization]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ResolveOrganizationCluster",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ResolvedOrganization], parsed)
    
    def SummarizeChunkWithContext(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "SummarizeChunkWithContext",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Summary, parsed)
    
    def SynthesizeNarrativeFromElements(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.Summary:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "SynthesizeNarrativeFromElements",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.Summary, parsed)
    
    def TrackConflictTrajectory(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> List[partial_types.ConflictArc]:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "TrackConflictTrajectory",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(List[partial_types.ConflictArc], parsed)
    
    def ValidateCypher(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.CypherQuery:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ValidateCypher",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.CypherQuery, parsed)
    
    def ValidateCypherOld(
        self,
        llm_response: str,
        baml_options: BamlCallOptions = {},
    ) -> partial_types.CypherQuery:
      __tb__ = baml_options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = baml_options.get("client_registry", None)

      parsed = self.__runtime.parse_llm_response(
        "ValidateCypherOld",
        llm_response,
        types,
        types,
        partial_types,
        True,
        self.__ctx_manager.get(),
        tb,
        __cr__,
      )

      return cast(partial_types.CypherQuery, parsed)
    


__all__ = ["LlmResponseParser", "LlmStreamParser"]